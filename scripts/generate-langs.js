#!/usr/bin/env node
/*
 * generate-langs.js
 * - Fetches all public repos for the configured username
 * - Aggregates language byte counts per repo via GitHub API
 * - Generates `assets/langs-donut.svg`
 *
 * Usage:
 *   GITHUB_TOKEN=... node scripts/generate-langs.js [username]
 */
const fs = require('fs');
const path = require('path');
const fetch = global.fetch || require('node-fetch');

const USERNAME = process.argv[2] || process.env.INPUT_USERNAME || (process.env.GITHUB_REPOSITORY ? process.env.GITHUB_REPOSITORY.split('/')[0] : 'arn-c0de');
const TOKEN = process.env.GITHUB_TOKEN || process.env.GH_TOKEN || null;
const OUT_PATH = path.resolve(__dirname, '..', 'assets', 'langs-donut.svg');

async function request(url) {
  const headers = { 'Accept': 'application/vnd.github+json' };
  if (TOKEN) headers['Authorization'] = `Bearer ${TOKEN}`;
  const res = await fetch(url, { headers });
  if (!res.ok) throw new Error(`${res.status} ${res.statusText} - ${url}`);
  return res.json();
}

async function fetchAllRepos() {
  const repos = [];
  let page = 1;
  while (true) {
    const url = `https://api.github.com/users/${USERNAME}/repos?per_page=100&page=${page}`;
    const data = await request(url);
    if (!data || data.length === 0) break;
    repos.push(...data);
    page += 1;
  }
  return repos.filter(r => !r.fork && !r.archived);
}

async function fetchLanguages(owner, repo) {
  const url = `https://api.github.com/repos/${owner}/${repo}/languages`;
  return request(url);
}

function formatBytes(bytes) {
  if (bytes === 0) return '0 B';
  const units = ['B','KB','MB','GB'];
  let u = 0;
  let val = bytes;
  while (val >= 1024 && u < units.length-1) { val /= 1024; u++; }
  return `${val.toFixed(1)} ${units[u]}`;
}

function makeSvg(langArray, totalBytes) {
  const width = 640;
  const height = 240;
  const r = 60;
  const cx = 150;
  const cy = 120;
  const circumference = 2 * Math.PI * r;

  const colors = [
    '#6366F1','#EF4444','#F97316','#F59E0B','#10B981','#06B6D4','#3B82F6','#8B5CF6','#EC4899','#94A3B8'
  ];

  let cumulative = 0;
  const segments = langArray.map((l, idx) => {
    const pct = l.bytes / totalBytes;
    const dash = `${(pct * circumference).toFixed(2)} ${circumference.toFixed(2)}`;
    const offset = -(cumulative * circumference).toFixed(2);
    cumulative += pct;
    return { ...l, color: colors[idx % colors.length], dash, offset };
  });

  const legendX = 330;
  const legendY = 40;
  const legendGap = 20;

  const now = new Date().toISOString();

  const svgParts = [];
  svgParts.push(`<!-- Generated by scripts/generate-langs.js on ${now} -->`);
  svgParts.push(`<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">`);
  svgParts.push(`<style>
    .label{font: 12px 'Segoe UI', Roboto, Arial; fill:#cbd5e1}
    .legend{font: 12px 'Segoe UI', Roboto, Arial; fill:#e2e8f0}
    .title{font: 14px 'Segoe UI', Roboto, Arial; fill:#ffffff; font-weight:600}
  </style>`);

  // Background
  svgParts.push(`<rect width="100%" height="100%" fill="#0b1220" rx="8"/>`);

  // Title
  svgParts.push(`<text x="20" y="26" class="title">Languages — aggregated across public repos</text>`);

  // Draw donut base
  svgParts.push(`<g transform="translate(${cx}, ${cy}) rotate(-90)">`);
  svgParts.push(`<circle r="${r}" cx="0" cy="0" fill="transparent" stroke="#11203a" stroke-width="20" />`);

  segments.forEach((s, i) => {
    svgParts.push(`<circle r="${r}" cx="0" cy="0" fill="transparent" stroke="${s.color}" stroke-width="20" stroke-linecap="butt"
      stroke-dasharray="${s.dash}" stroke-dashoffset="${s.offset}" transform="rotate(0)" />`);
  });

  svgParts.push(`</g>`);

  // Legend
  svgParts.push(`<g transform="translate(${legendX},${legendY})">`);
  langArray.forEach((l, i) => {
    const y = i * legendGap;
    const color = colors[i % colors.length];
    const pct = ((l.bytes / totalBytes) * 100).toFixed(1);
    svgParts.push(`<rect x="0" y="${y-12}" width="12" height="12" fill="${color}" rx="2"/>`);
    svgParts.push(`<text x="18" y="${y - 2}" class="legend">${l.lang} — ${pct}% (${formatBytes(l.bytes)})</text>`);
  });
  svgParts.push(`</g>`);

  svgParts.push(`<text x="20" y="216" class="label">Total: ${formatBytes(totalBytes)} — Generated: ${now.split('T')[0]}</text>`);

  svgParts.push(`</svg>`);

  return svgParts.join('\n');
}

(async function main(){
  try {
    console.log('Fetching repos for', USERNAME);
    const repos = await fetchAllRepos();
    console.log(`Found ${repos.length} repos (filtered fork/archived).`);

    const totals = {};
    for (const repo of repos) {
      try {
        const langs = await fetchLanguages(USERNAME, repo.name);
        for (const [lang, bytes] of Object.entries(langs)) {
          totals[lang] = (totals[lang] || 0) + bytes;
        }
      } catch (e) {
        console.warn('Failed to fetch languages for', repo.name, e.message);
      }
    }

    const totalBytes = Object.values(totals).reduce((a,b)=>a+b,0);
    if (totalBytes === 0) {
      const placeholder = `<!-- Generated on ${new Date().toISOString()} -->\n<svg xmlns="http://www.w3.org/2000/svg" width="400" height="120"><rect width="100%" height="100%" fill="#0b1220" rx="8"/><text x="20" y="40" fill="#e2e8f0">No language data available</text></svg>`;
      fs.mkdirSync(path.dirname(OUT_PATH), { recursive: true });
      fs.writeFileSync(OUT_PATH, placeholder, 'utf8');
      console.log('Wrote placeholder SVG (no language bytes).');
      return;
    }

    const langArray = Object.entries(totals).map(([lang, bytes]) => ({lang, bytes})).sort((a,b)=>b.bytes-a.bytes).slice(0,10);

    const svg = makeSvg(langArray, totalBytes);
    fs.mkdirSync(path.dirname(OUT_PATH), { recursive: true });
    fs.writeFileSync(OUT_PATH, svg, 'utf8');
    console.log('Wrote', OUT_PATH);
  } catch (err) {
    console.error('Error:', err);
    process.exit(1);
  }
})();
